Tutorial 5 : A Textured Cube
第五课：纹理方块
关于UV坐标
自行加载.BMP图片
在OpenGL中使用纹理
什么是滤波和mipmap？怎样使用？
	线性滤波（Linear filtering）
	各向异性滤波（Anisotropic filtering）
	Mipmap
怎样用GLFW中加载纹理？
压缩纹理
	创建压缩纹理
	使用压缩纹理
	反转UV坐标
总结
练习
参考文献

本课学习如下几点：
什么是UV坐标
怎样自行加载纹理
怎样在OpenGL中使用纹理
什么是滤波？什么是mipmap？怎样使用？
怎样利用GLFW更加鲁棒地加载纹理？
什么是alpha通道？

关于UV坐标
给一个网格贴纹理时，需要通过某种方式告诉OpenGL用哪一块图像来填充三角形。这是借助UV坐标来实现的。

每个顶点除了位置坐标外还有两个浮点数坐标：U和V。这两个坐标用于获取纹理，如下图所示：

注意纹理是怎样在三角形上扭曲的。

自行加载.BMP图片
了解BMP文件格式并不重要：很多库可以帮你做这个。但BMP格式极为简单，可以帮助你理解那些库的工作原理。所以，我们从头开始写一个BMP文件加载器，以便你理解其工作原理，不过（在实际工程中）千万别再用这个实验品。

如下是加载函数的声明：

使用方式如下：

接下来看看如何读取BMP文件。

首先需要一些数据。读取文件时将设置这些变量。

现在正式开始打开文件。

文件一开始是54字节长的文件头，用于标识“这是不是一个BMP文件”、图像大小、像素位等等。来读取文件头吧：

文件头总是以“BM”开头。实际上，如果用十六进制编辑器打开BMP文件，你会看到如下情形：

因此，得检查一下头两个字节是否确为‘B’和‘M’：

现在可以读取文件中图像大小、数据位置等信息了：

如果这些信息缺失得手动补齐：

现在我们知道了图像的大小，可以为之分配一些内存，把图像读进去：

到了真正的OpenGL部分了。创建纹理和创建顶点缓冲器差不多：
创建一个纹理、绑定、填充、配置。

在glTexImage2D函数中，GL_RGB表示颜色由三个分量构成，GL_BGR则说明在内存中颜色值是如何存储的。实际上，BMP存储的并不是RGB红绿蓝，而是BGR蓝绿红，因此得把这个告诉OpenGL。

稍后再解释最后两行代码。同时，得在C++代码中使用刚写好的函数加载一个纹理：

另外十分重要的一点：使用2次幂（power-of-two）的纹理！
	优质纹理：128*128、256*256、1024*1024、2*2……
	劣质纹理：127*128、3*5
	勉强可以但很怪异的纹理：128*256

在OpenGL中使用纹理
先来看看片断着色器。大部分代码一目了然：

注意三个点：
	片断着色器需要UV坐标。看似合情合理。
	同时也需要一个“Sampler2D”来获知要加载哪一个纹理（同一个着色器中可以访问多个纹理）
	最后一点，用texture()访问纹理，该方法返回一个(R,G,B,A)的vec4变量。马上就会了解到分量A。

顶点着色器也很简单，只需把UV坐标传给片断着色器：

还记得第四课中的“layout(location = 1) in vec2 vertexUV”	吗？我们得在这儿把相同的事情再做一遍，但这次的缓冲器中放的不是(R,G,B)三元组，而是(U,V)数对。

上述UV坐标对应于下面的模型：

其余的就很清楚了。创建一个缓冲器、绑定、填充、配置，与往常一样绘制顶点缓冲器对象。要注意把glVertexAttribPointer的第二个参数（大小）3改成2。

结果如下：

放大后：

什么是滤波和mipmap？怎样使用？

	线性滤波（Linear filtering）
	各向异性滤波（Anisotropic filtering）
	Mipmap
怎样用GLFW中加载纹理？
压缩纹理
	创建压缩纹理
	使用压缩纹理
	反转UV坐标
总结
刚刚学习的是创建、加载以及在OpenGL中使用纹理。
总的来说，压缩纹理体积小、加载迅速、使用便捷，应该只用压缩纹理；主要的缺点是得用The Compressonator来转换图像格式。

练习
源代码中实现了DDS加载器，但没有做纹理坐标的改动（译者注：指文中讲述的反转 UV坐标）。在适当的位置添加该功能，以使正方体正确显示。
试试各种DDS格式。所得结果有何不同？压缩率呢？
试试在The Compressonator不生成mipmap。结果如何？请给出3种方案解决这一问题。


参考文献
Using texture compression in OpenGL , Sébastien Domine, NVIDIA