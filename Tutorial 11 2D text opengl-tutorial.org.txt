本课将学习如何在三维场景之上绘制二维文本。本例是一个简单的计时器：In this tutorial, we'll learn to draw 2D text on top of our 3D content. In our case, this will be a simple timer :

<a href="http://www.opengl-tutorial.org/wp-content/uploads/2011/05/clock.png"><img class="alignnone size-large wp-image-292" title="clock" src="http://www.opengl-tutorial.org/wp-content/uploads/2011/05/clock-1024x793.png" alt="" width="640" height="495" /></a>
<h1>接口The API</h1>
我们将实现这些简单的接口（位于common/text2D.h）：We're going to implement this simple interface (in common/text2D.h):
<pre class="brush:cpp">void initText2D(const char * texturePath);
void printText2D(const char * text, int x, int y, int size);
void cleanupText2D();</pre>
为了让代码在640*480和1080p分辨率下都能正常工作，x和y的范围分别设为[0-800]和[0-600]。顶点着色器将根据实际屏幕大小做对它做调整。In order for the code to work at both 640*480 and 1080p, x and y will be coordinates in [0-800][0-600]. The vertex shader will adapt this to the actual size of the screen.

完整的实现代码请参阅common/text2D.cpp。See common/text2D.cpp for the complete implementation.
<h1>纹理The texture</h1>
initText2D简单地读取一个纹理和一些着色器，很好理解；来看看纹理：initText2D simply reads a texture and a couple of shaders. There's nothing fancy about it, but let's look at the texture :

<a href="http://www.opengl-tutorial.org/wp-content/uploads/2011/05/fontalpha.png"><img class="alignnone size-large wp-image-293" title="fontalpha" src="http://www.opengl-tutorial.org/wp-content/uploads/2011/05/fontalpha-1024x717.png" alt="" width="640" height="448" /></a>

该纹理由CBFG生成。CBFG是诸多从字体生成纹理的工具之一。把纹理加载到Paint.NET，加上红色背景（仅为了观察方便；本教程中的红色背景，都代表透明）。This texture was generated using <a href="http://www.codehead.co.uk/cbfg/">CBFG</a>, one of the many tools that generate textures from fonts. If was then imported in Paint.NET where I added a red background (for visualisation purposes only : everywhere you see red, it's supposed to be transparent ).

printText2D()在屏幕的适当位置，生成一个纹理坐标正确的四边形。The goal of printText2D will thus be to generate quads with the appropriate screen position and texture coordinates.
<h1>绘制Drawing</h1>
首先，填充这些缓冲区：We have to fill these buffers :
<pre class="brush:cpp">std::vector<glm::vec2> vertices;
std::vector<glm::vec2> UVs;</pre>
文本中的每个字母，都要计算其四边形包围盒的顶点坐标，然后添加两个三角形（组成一个四边形）：For each character, we compute the coordinates of the four vertices that will define the quad, and add the two triangles :
<pre class="brush:cpp">for ( unsigned int i=0 ; i<length ; i++ ){

    glm::vec2 vertex_up_left??? = glm::vec2( x+i*size???? , y+size );
    glm::vec2 vertex_up_right?? = glm::vec2( x+i*size+size, y+size );
    glm::vec2 vertex_down_right = glm::vec2( x+i*size+size, y????? );
    glm::vec2 vertex_down_left? = glm::vec2( x+i*size???? , y????? );

    vertices.push_back(vertex_up_left?? );
    vertices.push_back(vertex_down_left );
    vertices.push_back(vertex_up_right? );

    vertices.push_back(vertex_down_right);
    vertices.push_back(vertex_up_right);
    vertices.push_back(vertex_down_left);</pre>
轮到UV坐标了。计算左上角的坐标：Now for the UVS. The upper-left coordinate is computed as follows :
<pre class="brush:cpp">    char character = text[i];
    float uv_x = (character%16)/16.0f;
    float uv_y = (character/16)/16.0f;</pre>
这样做是对的（基本上对，详见下文），因为A的ASCII值为65。This works ( sort of - see below ) because the <a href="http://www.asciitable.com/">ASCII code for A</a> is 65.

65%16 = 1，因此A位于第1列（列号从0开始）。65%16 = 1, so A is on column #1 (starts at 0 !).

65/16 = 4，因此A位于第4行（这是整数除法，所以结果不是想象中的4.0625）65/16 = 4, so A is on line #4 ( it's integer division, so it's not 4.0625 as it should be)

两者都除以16.0以使之落于[0.0 - 1.0]区间内，这正是OpenGL纹理所需的。Both are divided by 16.0 to fit in the [0.0 - 1.0] range needed by OpenGL textures.

现在只需对顶点重复相同的操作：And now we just have to do the very same thing than we did, but for the vertices :
<pre class="brush:cpp">    glm::vec2 uv_up_left??? = glm::vec2( uv_x?????????? , 1.0f - uv_y );
    glm::vec2 uv_up_right?? = glm::vec2( uv_x+1.0f/16.0f, 1.0f - uv_y );
    glm::vec2 uv_down_right = glm::vec2( uv_x+1.0f/16.0f, 1.0f - (uv_y + 1.0f/16.0f) );
    glm::vec2 uv_down_left? = glm::vec2( uv_x?????????? , 1.0f - (uv_y + 1.0f/16.0f) );

    UVs.push_back(uv_up_left?? );
    UVs.push_back(uv_down_left );
    UVs.push_back(uv_up_right? );

    UVs.push_back(uv_down_right);
    UVs.push_back(uv_up_right);
    UVs.push_back(uv_down_left);
 }</pre>
其余的操作和往常一样：绑定缓冲区，填充，选择着色器程序，绑定纹理，开启、绑定、配置顶点属性，开启混合，调用glDrawArrays。哒哒，完事儿了。The rest is just as usual : bind the buffers, fill them, select the shader program, bind the texture, enable/bend/configure the vertex attributes, enable the blending, and call glDrawArrays. Hooray ! You're done.

注意非常重要的一点：这些坐标位于[0,800][0,600]范围内。也就是说，这里不需要矩阵。顶点着色器只需简单换算就可以把这些坐标转换到[-1,1][-1,1]范围内（也可以在C++代码中完成这一步）。Note a very important thing : the coordinates are generated in the [0,800][0,600] range. In other words, there is NO NEED for a matrix here. The vertex shader simply has to put it in the [-1,1][-1,1] range with very simple math (this could be done in C++ too) :
<pre class="brush:vs">void main(){

?? ?// Output position of the vertex, in clip space
?? ?// map [0..800][0..600] to [-1..1][-1..1]
?? ?vec2 vertexPosition_homoneneousspace = vertexPosition_screenspace - vec2(400,300); // [0..800][0..600] -> [-400..400][-300..300]
?? ?vertexPosition_homoneneousspace /= vec2(400,300);
?? ?gl_Position =? vec4(vertexPosition_homoneneousspace,0,1);

?? ?// UV of the vertex. No special space for this one.
?? ?UV = vertexUV;
}</pre>
片断着色器的工作也很少：The fragment shader does very little too :
<pre class="brush:fs">void main(){
?? ?color = texture( myTextureSampler, UV );
}</pre>
顺便说一下，别在工程中使用这些代码，因为它只能处理拉丁字符。否则你的产品在印度、中国、日本（甚至德国，因为纹理上没有ß）就别想卖了。这幅纹理是我用法国字符集生成的，在法国用用还可以（注意 é, à, ç等字母）。修改其他教程的代码时，注意库的使用。别的教程大多使用OpenGL 2，和本教程不兼容。很可惜，我还没找到一个足够好的，能处理UTF-8字符集的库。By the way, don't use this code for production, since it only handles the Latin alphabet. Or don't sell anything to India, China, Japan ( or even Germany, since there is no ? on this image ). This texture will mostly work in France (notice the é, à, ?, etc) because it's been generated with my locale. And beware while adapting code from other tutorials of when using libraries, most of them use OpenGL 2, which isn't compatible. Unfortunately I don't know any good-enough library to which handles UTF-8.

顺带提一下，你应该看看Joel Spolsky写的。By the way, you should read <a href="http://www.joelonsoftware.com/articles/Unicode.html">The Absolute Minimum Every Software Developer Absolutely, Positively Must Know About Unicode and Character Sets (No Excuses!)</a> by Joel Spolsky.