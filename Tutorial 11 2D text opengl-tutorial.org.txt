本课将学习如何在3D场景之上绘制2D文本。本例是一个简单的计时器：In this tutorial, we'll learn to draw 2D text on top of our 3D content. In our case, this will be a simple timer :

<a href="http://www.opengl-tutorial.org/wp-content/uploads/2011/05/clock.png"><img class="alignnone size-large wp-image-292" title="clock" src="http://www.opengl-tutorial.org/wp-content/uploads/2011/05/clock-1024x793.png" alt="" width="640" height="495" /></a>
<h1>The API</h1>
我们将实现这些简单的接口（位于common/text2D.h）：We're going to implement this simple interface (in common/text2D.h):
<pre class="brush:cpp">void initText2D(const char * texturePath);
void printText2D(const char * text, int x, int y, int size);
void cleanupText2D();</pre>
为了让代码在640*480和1080p分辨率下都能正常工作，x和y的范围分别设为[0-800]和[0-600]。顶点着色器将根据实际屏幕的大小做相应调整。In order for the code to work at both 640*480 and 1080p, x and y will be coordinates in [0-800][0-600]. The vertex shader will adapt this to the actual size of the screen.

完整的实现代码请参阅common/text2D.cpp。See common/text2D.cpp for the complete implementation.
<h1>纹理The texture</h1>
initText2D简单地读取一个纹理和一些着色器。函数没什么值得深究的，来看看纹理：initText2D simply reads a texture and a couple of shaders. There's nothing fancy about it, but let's look at the texture :

<a href="http://www.opengl-tutorial.org/wp-content/uploads/2011/05/fontalpha.png"><img class="alignnone size-large wp-image-293" title="fontalpha" src="http://www.opengl-tutorial.org/wp-content/uploads/2011/05/fontalpha-1024x717.png" alt="" width="640" height="448" /></a>

该纹理由CBFG生成。CBFG是一款字体纹理生成器。把纹理加载到Paint.NET后加上红色背景（红色背景仅为便于观察，其实是透明的）。This texture was generated using <a href="http://www.codehead.co.uk/cbfg/">CBFG</a>, one of the many tools that generate textures from fonts. If was then imported in Paint.NET where I added a red background (for visualisation purposes only : everywhere you see red, it's supposed to be transparent ).

printText2D函数用于在屏幕上的适当位置生成一块四边形，并把纹理放在正确的位置。The goal of printText2D will thus be to generate quads with the appropriate screen position and texture coordinates.
<h1>绘制Drawing</h1>
首先得填充这些缓冲区：We have to fill these buffers :
<pre class="brush:cpp">std::vector<glm::vec2> vertices;
std::vector<glm::vec2> UVs;</pre>
每个字都要计算其四边形四角的顶点坐标，然后添加这两个三角形：For each character, we compute the coordinates of the four vertices that will define the quad, and add the two triangles :
<pre class="brush:cpp">for ( unsigned int i=0 ; i<length ; i++ ){

    glm::vec2 vertex_up_left??? = glm::vec2( x+i*size???? , y+size );
    glm::vec2 vertex_up_right?? = glm::vec2( x+i*size+size, y+size );
    glm::vec2 vertex_down_right = glm::vec2( x+i*size+size, y????? );
    glm::vec2 vertex_down_left? = glm::vec2( x+i*size???? , y????? );

    vertices.push_back(vertex_up_left?? );
    vertices.push_back(vertex_down_left );
    vertices.push_back(vertex_up_right? );

    vertices.push_back(vertex_down_right);
    vertices.push_back(vertex_up_right);
    vertices.push_back(vertex_down_left);</pre>
轮到UV坐标了。左上角的坐标按如下过程计算：Now for the UVS. The upper-left coordinate is computed as follows :
<pre class="brush:cpp">    char character = text[i];
    float uv_x = (character%16)/16.0f;
    float uv_y = (character/16)/16.0f;</pre>
这样做是正确的（基本正确，详见下文），因为A的ASCII值为65。This works ( sort of - see below ) because the <a href="http://www.asciitable.com/">ASCII code for A</a> is 65.

65%16 = 1，因此A位于第1列（列号从0开始）。65%16 = 1, so A is on column #1 (starts at 0 !).

65/16 = 4，因此A位于第4行（这是整数除法，所以结果不是想象中的4.0625）65/16 = 4, so A is on line #4 ( it's integer division, so it's not 4.0625 as it should be)

两者都除以16.0以使之落于[0.0 - 1.0]区间内，这正是OpenGL纹理所需的。Both are divided by 16.0 to fit in the [0.0 - 1.0] range needed by OpenGL textures.

现在只需对顶点重复相同的操作：And now we just have to do the very same thing than we did, but for the vertices :
<pre class="brush:cpp">    glm::vec2 uv_up_left??? = glm::vec2( uv_x?????????? , 1.0f - uv_y );
    glm::vec2 uv_up_right?? = glm::vec2( uv_x+1.0f/16.0f, 1.0f - uv_y );
    glm::vec2 uv_down_right = glm::vec2( uv_x+1.0f/16.0f, 1.0f - (uv_y + 1.0f/16.0f) );
    glm::vec2 uv_down_left? = glm::vec2( uv_x?????????? , 1.0f - (uv_y + 1.0f/16.0f) );

    UVs.push_back(uv_up_left?? );
    UVs.push_back(uv_down_left );
    UVs.push_back(uv_up_right? );

    UVs.push_back(uv_down_right);
    UVs.push_back(uv_up_right);
    UVs.push_back(uv_down_left);
 }</pre>
其余的操作和往常一样：绑定缓冲区，填充，选择着色器程序，绑定纹理，开启、绑定、配置顶点属性，开启混合，调用glDrawArrays。哒哒，完事儿了。The rest is just as usual : bind the buffers, fill them, select the shader program, bind the texture, enable/bend/configure the vertex attributes, enable the blending, and call glDrawArrays. Hooray ! You're done.

注意非常重要的一点：这些坐标位于[0,800][0,600]范围内。也就是说，这里不需要矩阵。顶点着色器只需简单换算就可以把这些坐标转换到[-1,1][-1,1]范围内（也可以在C++代码中完成这一步）。Note a very important thing : the coordinates are generated in the [0,800][0,600] range. In other words, there is NO NEED for a matrix here. The vertex shader simply has to put it in the [-1,1][-1,1] range with very simple math (this could be done in C++ too) :
<pre class="brush:vs">void main(){

?? ?// Output position of the vertex, in clip space
?? ?// map [0..800][0..600] to [-1..1][-1..1]
?? ?vec2 vertexPosition_homoneneousspace = vertexPosition_screenspace - vec2(400,300); // [0..800][0..600] -> [-400..400][-300..300]
?? ?vertexPosition_homoneneousspace /= vec2(400,300);
?? ?gl_Position =? vec4(vertexPosition_homoneneousspace,0,1);

?? ?// UV of the vertex. No special space for this one.
?? ?UV = vertexUV;
}</pre>
片断着色器所做的工作也很少：The fragment shader does very little too :
<pre class="brush:fs">void main(){
?? ?color = texture( myTextureSampler, UV );
}</pre>
顺便说一下，别在实际产品中使用这些代码，它只处理了拉丁字符。或者别把产品销往印度、中国、日本（还有德国，因为纹理上没有）。这幅纹理是我用法国字符集生成的，在法国用用还可以（注意等字母）。修改别的课程的代码时注意库的使用。别的课程大多使用OpenGL 2，和本课程不兼容。可惜的是，我还不知道处理UTF-8的好库。By the way, don't use this code for production, since it only handles the Latin alphabet. Or don't sell anything to India, China, Japan ( or even Germany, since there is no ? on this image ). This texture will mostly work in France (notice the é, à, ?, etc) because it's been generated with my locale. And beware while adapting code from other tutorials of when using libraries, most of them use OpenGL 2, which isn't compatible. Unfortunately I don't know any good-enough library to which handles UTF-8.

顺带提一下，你应该看看Joel Spolsky写的。By the way, you should read <a href="http://www.joelonsoftware.com/articles/Unicode.html">The Absolute Minimum Every Software Developer Absolutely, Positively Must Know About Unicode and Character Sets (No Excuses!)</a> by Joel Spolsky.